像素距离：
    void distanceTransform(InArr src, OutArr dst, int distanceType,
        int maskSize, int dstType=CV_32F);
        //（近似）计算和最近的值为0的像素的距离
        - src：必须CV_8UC1
        - distancdType = DIST_
                            L1      |dx|+|dy|
                            L2      欧氏
                            C       max(|dx|, |dy|)
        - maskSize = 3 / 5
        - dstType = CV_8U/32F

    void distanceTransform(InArr, OutArr, OutArr labels, int, int,
        int labelType=DIST_LABEL_CCOMP);
        - labels：距离最近的0像素编号
        - labelType = DIST_LABEL_
                                CCOMP   同一个连通域的0像素的编号相同
                                PIXEL   每个0像素独立编号
        // 默认CV_32F输出

    计算流程：
        1.初始化：0像素距离值0
        2.遍历每个像素p，更新距离值 = mask内最小距离值 + p到该像素的距离
        3.左上到右下、右下到左上两次进行操作2

连通域：
    连通域是指：像素值相同且连通的区域
    4-领域：上下左右
    8-领域：+对角点

    二次扫描法：
        1.正向扫描：检测左、上
        2.逆向扫描：检测右、下

    种子填充法：
        上下左右递归；深度搜索

    int connectedComponents(InArr image, OutArr labels,
        int connectivity=8, int ltype=CV_32S, int ccltype=CCL_DEFAULT);
        - connectivity = 4/8（4-领域/8-领域）
        - ltype = CV_32S/16U：输出数据类型
        - ccltype = CCL_
                        DEFAULT
                        WU
                        GRANA
        // 返回连通域个数
        // 只统计非0像素；0像素编号0，后从左上到右下1、2、3...

    int connectedComponentsWithStats(InArr image, OutArr labels, OutArr stats,
        OutArr centroids, int connectivity=8, int ltype=CV_32S, int ccltype=CCL_DEFAULT);
        - stats：连通域状态（CV_32S）
        - centroids：连通域质心坐标（CV_64F）
        // stats.at<int>(label, CC_STAT_        )
                                    0   LEFT    左边界
                                    1   TOP     上边界
                                    2   WIDTH   宽
                                    3   HEIGHT  高
                                    4   AREA    面积
        // centroids.at<Point2d>(label);